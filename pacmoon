#!/usr/bin/env zsh

emulate zsh
setopt warnCreateGlobal extendedGlob noFunctionArgZero nullGlob

PACMOON_VERSION=0.7.1
AUR_BASE=http://aur.archlinux.org/packages
ABS_DIR=/var/abs
ABS_RSYNC=rsync.archlinux.org::abs
RSYNC_ARGS=(-mrtv --no-motd --no-p --no-o --no-g)

autoload jgetopt colors
colors

pmoonHome="${XDG_CONFIG_HOME:-$HOME/.config}/pacmoon"
logFile="$pmoonHome/log"
mkdir -p $pmoonHome/pkg || die "could not mkdir $pmoonHome/pkg"

typeset -A dep_status

info() {
    echo " $fg_bold[green]*$fg_no_bold[default] $*"
}

log_info() {
    info $*
    echo info: $* >> $logFile
}

warn() {
    echo " $fg_bold[yellow]*$fg_no_bold[default] $*"
    echo warn: $* >> $logFile
}

die() {
    echo " $fg_bold[red]*$fg_no_bold[default] $*"
    echo fatal: $* >> $logFile
    exit 1
}

error() {
    echo " $fg_bold[red]*$fg_no_bold[default] $*"
    echo error: $* >> $logFile
    [[ $+keep_going -eq 1 ]] || exit 1
}

verbose() {
    if [[ $+verbose -eq 1 ]] ; then
        echo " $fg_bold[cyan]*$fg_no_bold[default] $*"
    fi
}

list_uncompiled() {
    error "listing uncompiled packages not supported yet"
}

list_compiled() {
    error "listing compiled packages not supported yet"
}

list_pkgs() {
    error "listing packages not supported yet"
}


pushd_build_dir() {
    local build_dir="$pmoonHome/tmp/$1"
    mkdir -p $build_dir
    pushd $build_dir
}

pacman_output_field() {
    pacman 2>/dev/null ${(s: :)1} | grep "^$2" | sed 's/.*: //'
}

dbPath=$(pacman_output_field -v DB)
typeset -A split_pkgs
typeset -A requested_pkgs
typeset -a install_list
typeset -a cyclic_deps

is_dep() {
    [[ $+requested_pkgs[$1] -eq 0 ]] && ! pacman &>/dev/null -Qe $1
}

build_pkg() {
    local name=$1

    pushd "$pmoonHome/tmp/$name" || \
        die "could not cd to $pmoonHome/tmp/$name"
    rm -rf src

    typeset -a mkpkg_args
    mkpkg_args=(-f)
    if [[ $+split_pkgs[$name] -eq 1 ]] ; then
        # fullname only set for split packages
        mkpkg_args=($mkpkg_args --pkg "$split_pkgs[$name]")
    fi

    if is_dep $pkg ; then
        local as_dep
    fi

    log_info "build ${as_dep+dependency }package $name ($mkpkg_args)"

    rm -f *.pkg.tar.*
    if [[ $+quiet -eq 1 ]] ; then
        makepkg &>/dev/null $mkpkg_args
    else
        makepkg $mkpkg_args
    fi

    [[ $? -eq 0 ]] || die "could not build $name"

    # TODO: test split packages one by one
    as_root pacman --noconfirm -U ${as_dep+--asdeps} *.pkg.tar.* || \
        die "could not install package"

    # record the date the package was dep_status
    package-query -Qif %1 $name > "$pmoonHome/pkg/$name"
    [[ $+keep_temp = 0 ]] && rm -rf "$pmoonHome/tmp/$name"
    popd
}

collect_pkg_data() {
    local name=$1
    local repo=$2

    if [[ $repo = local ]] ; then
        warn "unsupported: AUR package $name"
    else
        verbose "adding package $name from $repo to install list"

        local basename=$(grep -A1 '%BASE%' \
               ${dbPath}/sync/$repo/$name-[0-9]*/desc | tail -n 1)

        if [[ -n $basename && $basename != $name ]] ; then
            if [[ $+split_pkgs[$basename] -eq 1 ]] ; then
                split_pkgs[$basename]+=" $name"
                return
            fi

            split_pkgs[$basename]=$name

            # already got here through another package in split
            if [[ $+dep_status[$basename] -eq 1 ]] ; then
                split_pkgs[$basename]+=" $basename"
                return
            fi
        else
            local basename=$name

            # already got here through split package
            if [[ $+split_pkgs[$basename] -eq 1 ]] ; then
                split_pkgs[$basename]+=" $name"
            fi
        fi

        pushd_build_dir $basename

        local arch=$(package-query -Sif %a $repo/$basename)
        local use_abs=0
        if [[ $+no_abs -eq 0 ]] ; then
            cp -r $ABS_DIR/$repo/$basename/* . && use_abs=1
        fi

        if [[ $use_abs -eq 0 ]] ; then
            rsync &>/dev/null $RSYNC_ARGS "$ABS_RSYNC/$arch/$repo/$basename/" .
            [[ $? -ne 0 ]] && \
                die "rsync connection died, could not retrieve $basename"
       fi

        typeset -a deps
        deps=( $(bash -c 'source /etc/makepkg.conf; source PKGBUILD && echo ${makedepends[@]}') )

        if [[ $#deps > 0 ]] ; then
            verbose "begin dependencies of $name"
            for dep in $deps ; do
                collect_pkg $dep
            done
            verbose "end dependencies of $name"
        fi

        install_list+=$basename
        popd
    fi
}

as_root() {
    if [[ $UID -eq 0 ]] ; then $* ; else sudo $* ; fi
}

resolve_name() {
    local name=$1
    local name_v=$2

    local pq_fmt="%1 %s %n %v"
    typeset -a pkgData
    pkgData=( $(package-query -Qf $pq_fmt --query-type provides $name_v || \
                package-query -Qif $pq_fmt $name_v || \
                package-query -Sif $pq_fmt $name_v) )

    if [[ -z $pkgData ]] ; then
        pkgData=( $(package-query -Sf $pq_fmt --query-type provides $name) )

        if [[ $#pkgData -ne 4 ]] ; then
            if [[ $#pkgData -lt 4 ]] ; then
                # TODO: check aur
                error "could not find package $name_v"
            else
                error "multiple packages provide $name_v"
                for ignore repo pr_name ver in "${(@)pkgData}" ; do
                    error "    $pr_name-$ver in $repo"
                done
                error "please install one of these and run this script again"
            fi
            return 1
        fi
    fi

    echo "$pkgData"
}

collect_pkg() {
    local name_v=$1

    local name=$(echo $name_v | sed 's/[<>=].*$//')

    # don't check the same package twice
    if [[ $+dep_status[$name] -eq 1 ]] ; then
        if [[ $dep_status[$name] -eq 2 ]] ; then
            cyclic_deps+=$name
            dep_status[$name]=1
        fi
        return 0
    fi

    dep_status[$name]=1

    typeset -a pkgData
    pkgData=( $(resolve_name $name $name_v) )
    [[ $? -ne 0 ]] && return

    # check if package conflicts with anything already installed
    local conflict
    conflict=$(package-query -Qf %n --query-type conflicts "$pkgData[3]=$pkgData[4]")
    if [[ -n $conflict ]] ; then
        verbose "$conflict conflicts with $pkgData[3]-$pkgData[4], installing $conflict"
        collect_pkg $conflict
        return
    fi

    if [[ $name != $pkgData[3] ]] ; then
        name=$pkgData[3]
        [[ $+dep_status[$name] -eq 0 ]] || return
        dep_status[$name]=1
    fi

    if [[ $pkgData[1] = - ]] ; then
        verbose "new package $name"
    elif [ -f $pmoonHome/pkg/$name ] ; then
        if [[ $pkgData[1] -le $(cat $pmoonHome/pkg/$name) ]] ; then
            verbose "package $name up to date and compiled"
            return
        else
            verbose "package $name was replaced by binary"
        fi
    else
        verbose "package $name installed but never compiled"
    fi

    dep_status[$name]=2
    collect_pkg_data $name $pkgData[2]
    dep_status[$name]=1
}

build_pkgs() {
    for pkg in $cyclic_deps ; do
        as_root pacman --needed --noconfirm -S $pkg || die \
            "could not get binary package for recursive dependency $pkg"
    done

    if [[ $#install_list -eq 0 ]] ; then
        log_info "nothing to install"
        return 0
    fi

    if [[ $+ask -eq 1 ]] ; then
        echo -n "Continue installing [yN]? "
        read ans
        if [[ $ans != Y && $ans != y ]] ; then
            exit 1
        fi
    fi

    for pkg in "${(@)install_list}" ; do
        build_pkg $pkg
    done
}

collect_all() {
    local logPath=$(pacman_output_field -v Log)

    if [[ -f "$pmoonHome/last_update" ]] ; then
        # TODO: use log to get list of candidates to compile
        :
    else
        warn "last update time not found, checking all installed packages"

        for pkg in $(pacman -Qq) ; do
            collect_pkg $pkg
        done
    fi
}

collect_pkgs() {
    if [[ $# = 0 ]] ; then
        collect_all
    else
        for pkg in $* ; do
            requested_pkgs[$pkg]=1
            collect_pkg $pkg
        done
    fi
}

main() {
    jgetopt $0 "$PACMOON_VERSION (please enjoy your evening)" \
        ':[packages]' \
        ask,a          "ask for confirmation before compiling" \
        pretend,p      "only print what would be done" \
        keep-going,k   "do not stop on error" \
        verbose,v      "increase verbosity" \
        quiet,q        "hide output of compilation" \
        keep-temp,T    "keep temporary files" \
        no-abs,A       "do not use local abs mirror (slower)" \
        uncompiled,u   "list packages which have not been custom compiled" \
        compiled,c     "list packages which have been custom compiled" \
        list,l         "list installed packages with their compilation status" \
        -- $*

    if [[ $+no_abs = 0 && ! -d $ABS_DIR ]] ; then
        warn "ABS directory is not available, reverting to downloading abs builds one at a time which is slower"
        warn "Please install 'abs' and run it to sync your local abs mirror"
        typeset -g no_abs
        no_abs=1
    fi

    if [[ $+uncompiled -eq 1 ]] ; then
        list_uncompiled
    elif [[ $+compiled -eq 1 ]] ; then
        list_compiled
    elif [[ $+list -eq 1 ]] ; then
        list_pkgs
    else
        info "please wait, collecting packages to build"
        collect_pkgs $positionals

        local sfx

        for pkg in $cyclic_deps ; do
            info $pkg "(as binary due to cyclic dependency)"
        done

        for pkg in "${(@)install_list}" ; do
            sfx=
            is_dep $pkg && sfx="(dependency)"
            info $pkg ${split_pkgs[$pkg]:+"($split_pkgs[$pkg])"} $sfx
        done

        [[ $+pretend -eq 0 ]] && build_pkgs
    fi
}

main $*
