#!/usr/bin/env zsh

emulate zsh
setopt warnCreateGlobal extendedGlob noFunctionArgZero

PACMOON_VERSION=0.1
AUR_BASE=http://aur.archlinux.org/packages
ABS_RSYNC=rsync.archlinux.org::abs
RSYNC_ARGS=(-mrtv --no-motd --no-p --no-o --no-g)

autoload jgetopt colors
colors

pmoonHome="$XDG_CONFIG_HOME/pacmoon"
logFile="$pmoonHome/log"
mkdir -p $pmoonHome/pkg || die "could not mkdir $pmoonHome/pkg"

typeset -A installed

list_uncompiled() {
}

info() {
    echo " $fg_bold[green]*$fg_no_bold[default] $*"
}

log_info() {
    info $*
    echo info: $* >> $logFile
}

warn() {
    echo " $fg_bold[yellow]*$fg_no_bold[default] $*"
    echo warn: $* >> $logFile
}

die() {
    echo " $fg_bold[red]*$fg_no_bold[default] $*"
    echo fatal: $* >> $logFile
    exit 1
}

error() {
    echo " $fg_bold[red]*$fg_no_bold[default] $*"
    echo error: $* >> $logFile
    [[ $+keep_going -eq 1 ]] || exit 1
}

verbose() {
    if [[ $+verbose -eq 1 ]] ; then
        echo " $fg_bold[cyan]*$fg_no_bold[default] $*"
    fi
}

pushd_new() {
    mkdir -p $1
    pushd $1
}

pacman_output_field() {
    pacman 2>/dev/null ${(s: :)1} | grep "^$2" | sed 's/.*: //'
}

dbPath=$(pacman_output_field -v DB)

compile_and_install() {
    local name=$1
    local repo=$2

    if [[ $repo = local ]] ; then
        verbose "installing $name from AUR"
    else
        verbose "installing $name from $repo"

        local split_name=$(grep -A1 '%BASE%' \
               ${dbPath}/sync/$repo/$name-[0-9]*/desc | tail -n 1)

        if [[ -n $split_name ]] ; then
            local tmp=$name
            name=$split_name
            split_name=$tmp
        fi

        local arch=$(package-query -Sif %a $repo/$name)
        if ! rsync &>/dev/null $RSYNC_ARGS "$ABS_RSYNC/$arch/$repo/$name/" .
        then
            die "rsync connection died"
        fi

        typeset -a deps
        deps=( $(bash -c 'source PKGBUILD && echo ${makedepends[@]}') )

        if [[ $#deps > 0 ]] ; then
            verbose "begin dependencies of $name"
            for dep in $deps ; do
                build_pkg $dep
            done
            verbose "end dependencies of $name"
        fi

        typeset -a mkpkg_args
        mkpkg_args=(-i --noconfirm)
        if [[ $+split_name -eq 1 ]] ; then
            mkpkg_args=($mkpkg_args --pkg $split_name)
        fi

        if [[ $+quiet -eq 1 ]] ; then
            makepkg &>/dev/null $mkpkg_args
        else
            makepkg $mkpkg_args
        fi

        [[ $? -eq 0 ]] || die "could not build $name from $repo"

        # record the date the package was installed
        package-query -Qif %1 $name > "$pmoonHome/pkg/$name"
        [[ -z $temp ]] && rm -rf "$pmoonHome/tmp/$name"
    fi
}

as_root() {
    if [[ $UID -eq 0 ]] ; then $* ; else sudo $* ; fi
}

build_pkg() {
    local name=$1

    # don't check the same package twice
    if [[ $+installed[$name] -eq 1 ]] ; then
        if [[ $installed[$name] -eq 2 ]] ; then
            log_info "installing binary package $name due to dependency cycle"
            as_root pacman --needed --noconfirm -S $name || die \
                "could not get binary package for recursive dependency $name"
            installed[$name]=1
        fi
        return 0
    fi
    installed[$name]=1

    typeset -a pkgData
    pkgData=( $(package-query -Qf "%1 %s %n" --query-type provides $name || \
                package-query -Sif "%1 %s %n" $name) )

    if [[ -z $pkgData ]] ; then
        # TODO: file might be in aur
        error "could not find package $name"
        return 1
    fi

    if [[ $name != $pkgData[3] ]] ; then
        name=$pkgData[3]
        [[ $+installed[$name] -eq 0 ]] || return
        installed[$name]=1
    fi

    if [[ $pkgData[1] = - ]] ; then
        log_info "new package $name"
    elif [ -f $pmoonHome/pkg/$name ] ; then
        if [[ $pkgData[1] -le $(cat $pmoonHome/pkg/$name) ]] ; then
            info "package $name up to date and compiled"
            return
        else
            log_info "package $name was replaced by binary"
        fi
    else
        log_info "package $name installed but never compiled"
    fi

    pushd_new "$pmoonHome/tmp/$name"
    installed[$name]=2
    compile_and_install $name $pkgData[2]
    installed[$name]=1
    popd
}

build_pkgs() {
    for pkg in $* ; do build_pkg $pkg ; done
}

build_all() {
    local logPath=$(pacman_output_field -v Log)

    if [[ -f "$pmoonHome/last_update" ]] ; then
        :
    else
        warn "last update time not found, checking all files manually"

        for pkg in $(pacman -Qq) ; do
            build_pkg $pkg
        done
    fi
}

main() {
    jgetopt $0 "$PACMOON_VERSION (please enjoy your evening)" \
        verbose,v      "increase verbosity" \
        keep-going,k   "do not stop on error" \
        pretend,p      "only print what would be done" \
        uncompiled,u   "list packages which have not been custom compiled" \
        quiet,q        "hide output of compilation" \
        temp,T         "keep temporary files" \
        -- $*

    if [[ $+uncompiled -eq 1 ]] ; then
        list_uncompiled
    elif [[ $#positionals > 0 ]] ; then
        build_pkgs $positionals
    else
        build_all
    fi
}

main $*
