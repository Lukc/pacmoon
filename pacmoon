#!/usr/bin/env zsh

emulate zsh
setopt warnCreateGlobal extendedGlob noFunctionArgZero

PACMOON_VERSION=0.1
AUR_BASE=http://aur.archlinux.org/packages
ABS_RSYNC=rsync.archlinux.org::abs
RSYNC_ARGS=(-mrtv --no-motd --delete-after --no-p --no-o --no-g)

autoload jgetopt colors
colors

configBase="$XDG_CONFIG_HOME/pacmoon"
mkdir -p $configBase/pkg || die "could not mkdir $configBase/pkg"

typeset -A installed

list_uncompiled() {
}

warn() {
    echo " $fg_bold[yellow]*$fg_no_bold[default] $*"
}

die() {
    echo " $fg_bold[red]*$fg_no_bold[default] $*"
    exit 1
}

error() {
    echo " $fg_bold[red]*$fg_no_bold[default] $*"
    [[ $+keep_going = 1 ]] || exit 1
}

verbose() {
    if [[ $+verbose = 1 ]] ; then
        echo " $fg_bold[cyan]*$fg_no_bold[default] $*"
    fi
}

pushd_new() {
    mkdir -p $1
    pushd $1
}

pacman_output_field() {
    pacman 2>/dev/null ${(s: :)1} | grep "^$2" | sed 's/.*: //'
}

dbPath=$(pacman_output_field -v DB)

compile_and_install() {
    local name=$1
    local repo=$2

    if [[ $repo = local ]] ; then
        verbose "installing $name from AUR"
    else
        verbose "installing $name from $repo"
        local arch=$(package-query -Sif %a $repo/$name)
        if ! rsync &>/dev/null $RSYNC_ARGS "$ABS_RSYNC/$arch/$repo/$name/" . ; then
            # TODO: file might be split

            # TODO: fallback

            error "rsync connection died"
            return 1
        fi

        typeset -a deps
        deps=( $(bash -c 'source PKGBUILD && echo ${makedepends[@]}') )

        if [[ $#deps > 0 ]] ; then
            verbose "begin dependencies of $name"
            for dep in $deps ; do
                build_pkg $dep
            done
            verbose "end dependencies of $name"
        fi

        makepkg -i --noconfirm || die "could not build $name from $repo"

        # record the date the package was installed
        package-query -Qif %1 $name > "$configBase/pkg/$name"
        [[ -z $temp ]] && rm -rf "$configBase/tmp/$name"
    fi
}

build_pkg() {
    local name=$1

    # don't check the same package twice
    [[ $+installed[$name] = 0 ]] || return
    installed[$name]=1

    typeset -a pkgData
    pkgData=( $(package-query -Qf "%1 %s %n" --query-type provides $name || \
                package-query -Sif "%1 %s %n" $name) )

    if [[ -z $pkgData ]] ; then
        # TODO: file might be in aur
        error "could not find package $name"
        return 1
    fi

    if [[ $name != $pkgData[3] ]] ; then
        name=$pkgData[3]
        [[ $+installed[$name] = 0 ]] || return
        installed[$name]=1
    fi

    if [[ $pkgData[1] = - ]] ; then
        verbose "new package $name"
    elif [ -f $configBase/pkg/$name ] ; then
        if [[ $pkgData[1] -le $(cat $configBase/pkg/$name) ]] ; then
            verbose "package $name up to date and compiled"
            return
        else
            verbose "package $name was replaced by binary"
        fi
    else
        verbose "package $name installed but never compiled"
    fi

    pushd_new "$configBase/tmp/$name"
    compile_and_install $name $pkgData[2]
    popd
}

build_pkgs() {
    for pkg in $* ; do build_pkg $pkg ; done
}

build_all() {
    local logPath=$(pacman_output_field -v Log)

    if [[ -f "$configBase/last_update" ]] ; then
        :
    else
        warn "last update time not found, checking all files manually"

        for pkg in $(pacman -Qq) ; do
            build_pkg $pkg
        done
    fi
}

main() {
    jgetopt $0 "$PACMOON_VERSION (please enjoy your evening)" \
        verbose,v      "increase verbosity" \
        keep-going,k   "do not stop on error" \
        pretend,p      "only print what would be done" \
        uncompiled,u   "list packages which have not been custom compiled" \
        temp,T         "keep temporary files" \
        -- $*

    if [[ $+uncompiled = 1 ]] ; then
        list_uncompiled
    elif [[ $#positionals > 0 ]] ; then
        build_pkgs $positionals
    else
        build_all
    fi
}

main $*
