#!/usr/bin/env zsh

emulate zsh
setopt warnCreateGlobal extendedGlob noFunctionArgZero nullGlob

PACMOON_VERSION=0.6
AUR_BASE=http://aur.archlinux.org/packages
ABS_DIR=/var/abs
ABS_RSYNC=rsync.archlinux.org::abs
RSYNC_ARGS=(-mrtv --no-motd --no-p --no-o --no-g)

autoload jgetopt colors
colors

pmoonHome="${XDG_CONFIG_HOME:-$HOME/.config}/pacmoon"
logFile="$pmoonHome/log"
mkdir -p $pmoonHome/pkg || die "could not mkdir $pmoonHome/pkg"

typeset -A dep_status

info() {
    echo " $fg_bold[green]*$fg_no_bold[default] $*"
}

log_info() {
    info $*
    echo info: $* >> $logFile
}

warn() {
    echo " $fg_bold[yellow]*$fg_no_bold[default] $*"
    echo warn: $* >> $logFile
}

die() {
    echo " $fg_bold[red]*$fg_no_bold[default] $*"
    echo fatal: $* >> $logFile
    exit 1
}

error() {
    echo " $fg_bold[red]*$fg_no_bold[default] $*"
    echo error: $* >> $logFile
    [[ $+keep_going -eq 1 ]] || exit 1
}

verbose() {
    if [[ $+verbose -eq 1 ]] ; then
        echo " $fg_bold[cyan]*$fg_no_bold[default] $*"
    fi
}

list_uncompiled() {
    error "listing uncompiled packages not supported yet"
}

list_compiled() {
    error "listing compiled packages not supported yet"
}

list_pkgs() {
    error "listing packages not supported yet"
}


pushd_build_dir() {
    local build_dir="$pmoonHome/tmp/$1"
    mkdir -p $build_dir
    pushd $build_dir
}

pacman_output_field() {
    pacman 2>/dev/null ${(s: :)1} | grep "^$2" | sed 's/.*: //'
}

dbPath=$(pacman_output_field -v DB)
typeset -A split_pkgs
typeset -a install_list

build_pkg() {
    local name=$1
    local as_dep=$2

    pushd "$pmoonHome/tmp/$name" || \
        die "could not cd to $pmoonHome/tmp/$name"
    rm -rf src

    typeset -a mkpkg_args
    mkpkg_args=(-f)
    if [[ $+split_pkgs[$name] -eq 1 ]] ; then
        # fullname only set for split packages
        mkpkg_args=($mkpkg_args --pkg "$split_pkgs[$name]")
    fi

    log_info "build ${as_dep:+dependency }package $name ($mkpkg_args)"

    rm -f *.pkg.tar.*
    if [[ $+quiet -eq 1 ]] ; then
        makepkg &>/dev/null $mkpkg_args
    else
        makepkg $mkpkg_args
    fi

    [[ $? -eq 0 ]] || die "could not build $name from $repo"

    as_root pacman --noconfirm -U ${as_dep:+--asdeps} *.pkg.tar.* || \
        die "could not install package"

    # record the date the package was dep_status
    package-query -Qif %1 $name > "$pmoonHome/pkg/$name"
    [[ $+keep_temp = 0 ]] && rm -rf "$pmoonHome/tmp/$name"
    popd
}

collect_deps() {
    local name=$1
    local repo=$2
    local is_dep=$3

    if [[ $repo = local ]] ; then
        warn "unsupported: AUR package $name"
    else
        verbose "adding package $name from $repo to install list"

        local basename=$(grep -A1 '%BASE%' \
               ${dbPath}/sync/$repo/$name-[0-9]*/desc | tail -n 1)

        if [[ -n $basename && $basename != $name ]] ; then
            if [[ $+split_pkgs[$basename] -eq 1 ]] ; then
                split_pkgs[$basename]+=" $name"
                return
            else
                split_pkgs[$basename]=$name
            fi
        else
            basename=$name
        fi

        pushd_build_dir $basename

        local arch=$(package-query -Sif %a $repo/$basename)
        local use_abs=0
        if [[ $+no_abs -eq 0 ]] ; then
            cp -r $ABS_DIR/$repo/$basename/* . && use_abs=1
        fi

        if [[ $use_abs -eq 0 ]] ; then
            rsync &>/dev/null $RSYNC_ARGS "$ABS_RSYNC/$arch/$repo/$basename/" .
            [[ $? -ne 0 ]] && \
                die "rsync connection died, could not retrieve $basename"
       fi

        typeset -a deps
        deps=( $(bash -c 'source /etc/makepkg.conf; source PKGBUILD && echo ${makedepends[@]}') )

        if [[ $#deps > 0 ]] ; then
            verbose "begin dependencies of $name"
            for dep in $deps ; do
                collect_pkg $dep 1
            done
            verbose "end dependencies of $name"
        fi

        install_list+=($basename "$is_dep")
        popd
    fi
}

as_root() {
    if [[ $UID -eq 0 ]] ; then $* ; else sudo $* ; fi
}

collect_pkg() {
    local name=$1
    local is_dep=$2

    # don't check the same package twice
    if [[ $+dep_status[$name] -eq 1 ]] ; then
        if [[ $dep_status[$name] -eq 2 ]] ; then
            log_info "installing binary package $name due to dependency cycle"
            as_root pacman --needed --noconfirm -S $name || die \
                "could not get binary package for recursive dependency $name"
            dep_status[$name]=1
        fi
        return 0
    fi
    dep_status[$name]=1

    typeset -a pkgData
    pkgData=( $(package-query -Qf "%1 %s %n" --query-type provides $name || \
                package-query -Qif "%1 %s %n" $name || \
                package-query -Sif "%1 %s %n" $name) )

    if [[ -z $pkgData ]] ; then
        # TODO: file might be in aur
        pkgData=( $(package-query -Sf "%1 %s %n" --query-type provides $name) )
        if [[ $#pkgData -ne 3 ]] ; then
            if [[ $#pkgData -lt 3 ]] ; then
                error "could not find package $name"
            else
                error "multiple packages provide $name"
                for ignore repo pr_name in "${(@)pkgData}" ; do
                    error "    $pr_name in $repo"
                done
                error "please install one of these and run this script again"
            fi
            return 1
        fi
    fi

    if [[ $name != $pkgData[3] ]] ; then
        name=$pkgData[3]
        [[ $+dep_status[$name] -eq 0 ]] || return
        dep_status[$name]=1
    fi

    if [[ $pkgData[1] = - ]] ; then
        verbose "new package $name"
    elif [ -f $pmoonHome/pkg/$name ] ; then
        if [[ $pkgData[1] -le $(cat $pmoonHome/pkg/$name) ]] ; then
            verbose "package $name up to date and compiled"
            return
        else
            verbose "package $name was replaced by binary"
        fi
    else
        verbose "package $name installed but never compiled"
    fi

    dep_status[$name]=2
    collect_deps $name $pkgData[2] $is_dep
    dep_status[$name]=1
}

build_pkgs() {
    if [[ $#install_list -eq 0 ]] ; then
        log_info "nothing to install"
        return 0
    fi

    for pkg isdep in "${(@)install_list}" ; do
        info $pkg ${isdep:+"(dependency)"}
    done

    if [[ $+ask -eq 1 ]] ; then
        echo -n "Continue installing [yN]? "
        read ans
        if [[ $ans != Y && $ans != y ]] ; then
            exit 1
        fi
    fi

    for pkg isdep in "${(@)install_list}" ; do
        build_pkg $pkg $isdep
    done
}

collect_all() {
    local logPath=$(pacman_output_field -v Log)

    if [[ -f "$pmoonHome/last_update" ]] ; then
        # TODO: use log to get list of candidates to compile
        :
    else
        warn "last update time not found, checking all installed packages"

        for pkg in $(pacman -Qq) ; do
            collect_pkg $pkg
        done
    fi
}

collect_pkgs() {
    if [[ $# = 0 ]] ; then
        collect_all
    else
        for pkg in $* ; do collect_pkg $pkg; done
    fi
}

main() {
    jgetopt $0 "$PACMOON_VERSION (please enjoy your evening)" \
        ask,a          "ask for confirmation before compiling" \
        pretend,p      "only print what would be done" \
        keep-going,k   "do not stop on error" \
        verbose,v      "increase verbosity" \
        quiet,q        "hide output of compilation" \
        keep-temp,T    "keep temporary files" \
        no-abs,A       "do not use local abs mirror (slower)" \
        uncompiled,u   "list packages which have not been custom compiled" \
        compiled,c     "list packages which have been custom compiled" \
        list,l         "list installed packages with their compilation status" \
        -- $*

    if [[ $+no_abs = 0 && ! -d $ABS_DIR ]] ; then
        warn "ABS directory is not available, reverting to downloading abs builds one at a time which is slower"
        warn "Please install 'abs' and run it to sync your local abs mirror"
        typeset -g no_abs
        no_abs=1
    fi

    if [[ $+uncompiled -eq 1 ]] ; then
        list_uncompiled
    elif [[ $+compiled -eq 1 ]] ; then
        list_compiled
    elif [[ $+list -eq 1 ]] ; then
        list_pkgs
    else
        info "please wait, collecting packages to build"
        collect_pkgs $positionals
        build_pkgs
    fi
}

main $*
